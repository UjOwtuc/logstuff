// vim: ft=rust :
use std::str::FromStr;

use crate::ast;

grammar;

pub Identifier: ast::Identifier = <r"[a-zA-Z_][a-zA-Z0-9._-]*"> => ast::Identifier::from(<>.to_string());

Operator: ast::Operator = {
    "=" => ast::Operator::Eq,
    "<" => ast::Operator::Lt,
    "<=" => ast::Operator::Le,
    ">" => ast::Operator::Gt,
    ">=" => ast::Operator::Ge,
    "like" => ast::Operator::Like,
    "in" => ast::Operator::In,
}

Integer: i64 = <r"(0|-?[1-9][0-9]*)"> => i64::from_str(<>).unwrap();
Float: f64 = <r"-?(0|[1-9][0-9]*)\.[0-9]+"> => f64::from_str(<>).unwrap();
QuotedString: String = {
    <s:r#""([^\\"]|\\[tnr\\"])*""#> =>
        s[1..s.len() - 1]
            .replace("\\\"", "\"")
            .replace("\\t", "\t")
            .replace("\\n", "\n")
            .replace("\\r", "\r")
            .replace("\\\\", "\\"),
    <s:r#"'([^\\']|\\[tnr\\'])*'"#> =>
        s[1..s.len() - 1]
            .replace("\\'", "'")
            .replace("\\t", "\t")
            .replace("\\n", "\n")
            .replace("\\r", "\r")
            .replace("\\\\", "\\"),
};

pub Scalar: ast::Scalar = {
    Integer => ast::Scalar::from(<>),
    Float => ast::Scalar::from(<>),
    QuotedString => ast::Scalar::from(<>),
}

pub List: Vec<ast::Scalar> = {
    "()" => Vec::new(),
    "(" <mut v:(<Scalar> ",")*> <e:Scalar> ")" => {
        v.push(e);
        v
    }
};

pub Term: Box<ast::Expression> = {
    <id:Identifier> <op:Operator> <v:Scalar> => Box::new(ast::Expression::Compare(id, op, ast::Value::Scalar(v))),
    <id:Identifier> <op:Operator> <v:List> => Box::new(ast::Expression::Compare(id, op, ast::Value::List(v))),
    <QuotedString> => Box::new(ast::Expression::FullTextSearch(<>)),
}

pub Expression: Box<ast::Expression> = {
    <lhs:Expression> "or" <rhs:AndExpr> => Box::new(ast::Expression::Or(lhs, rhs)),
    AndExpr,
}

AndExpr: Box<ast::Expression> = {
    <lhs:AndExpr> "and" <rhs:NegatedExpr> => Box::new(ast::Expression::And(lhs, rhs)),
    NegatedExpr,
}

NegatedExpr: Box<ast::Expression> = {
    "not" <expr:ParenthesizedExpr> => Box::new(ast::Expression::Not(expr)),
    ParenthesizedExpr,
}

ParenthesizedExpr: Box<ast::Expression> = {
    "(" <e:Expression> ")" => e,
    Term,
}
